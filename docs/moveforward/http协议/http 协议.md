## http 协议

[TOC]

#### http 的报文结构

-   开始行(请求行/响应行)
-   首部行
-   实体主体

#### http 的状态码

-   200 OK：表示客户端请求成功;
-   400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解;
-   401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用;
-   403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;
-   404 Not Found：请求的资源不存在，例如，输入了错误的 URL;
-   500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求;
-   503 Service Unavailable：服务器目前无法使用 ，表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;
-   501：服务器不具备完成请求的功能 例如：服务器无法识别请求方法的时候 可能回返回这个状态码
-   502：bad getway 服务器故障
-   504： 网关超时

#### http 的 header

| Accept-encoding | 浏览器能够编码的数据编码方式       |
| --------------- | ---------------------------------- |
| Connection      | 长连接(连接方式 可以设置为 close ) |
| origin          | 请求来源                           |
| user-Agent      | 浏览器类型 客户端的信息            |
| cache-control   | 缓存                               |
| cookie          | 客户端暂存 cookie 的信息           |
| content-type    | 资源类型                           |
| accept-language | 客户端可接受的语言                 |

#### https 和 http

1. Https 协议需要到 ca 申请证书，免费证书很少。
2. http 是超文本传输协议，信息是明文传输。 https 是具有安全性的 ssl 加密传输协议
3. 使用的端口号不一样 http 使用 80 端口 https 使用 443 端口
4. https 使用 ssl+http 联合起来构建的可进行身份验证、加密传输的协议，相比于 http 更加安全

#### https 的缺点

-   握手阶段比较费时，使页面的加载时间延长近 50%
-   连接缓存不如 http 高效，增加数据开销和功耗
-   ssl 证书需要钱
-   加密范围有限 在黑客攻击这方便 几乎起不到什么作用

### 报文头 响应字段

### content-type

> 实体头部 用于指示资源类型 告诉客户端 实际返回内容的内容类型

[http 请求中的 content-type](https://segmentfault.com/a/1190000013056786)

媒体查询格式

-   text/html
-   text/xml
-   text/plain 纯文本格式
-   image/ gif、jpeg、png

以 application 开头的媒体格式类型

-   application/json 序列化之后的 json 字符串
-   application/x-www-form-urlencode 浏览器元素的 form 表单 不设置 enctype 属性
-   multipart/form-data 这是 enctype 的值

### 对称加密和非对称加密的区别

-   对称加密采用了对称密码编码技术，特点是文件加密和解密使用相同的密钥

-   非对称加密算法 需要使用两个密钥，公开密钥和私有密钥。

    ```
    如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
    ```

### TCP 链接

> tcp 是一个端到端的面向连接的协议。http 基于 tcp。客户端与服务端的 tcp 链接 也就是三次握手 而关闭链接的时候 需要四次挥手

\- 三次握手

\- 第一次握手： 表明客户端打算链接服务器

\- 第二次： 服务端确定收到客服端应答 向客户端发送确认包应答

\- 第三次： 客服端再次发送确认包

\- 四次挥手：

\- 第一次： 客户端想要关闭连接 表示自己没有数据可以发送了 但是依然可以接受数据

\- 第二次： 服务端确认收到 关闭连接的请求 但是还没有准备好关闭链接（还有数据没有传输完毕）

\- 第三次：服务端准备好关闭 向客户端发送结束链接请求

\- 第四次： 客服端接收端服务端的关闭请求 发送一个确认包进入 wait 状态 服务端收到确认包之后关闭链接进入 closed 状态。客户端等待个固定的时间（2msl）之后，没有收到服务端的 ack，于是自己也关闭连接，进入 closed 状态

> 2msl 最大报文段生存时间 规定是 2 分钟 实际中常用的是 30 秒 1 分种和两分钟

### tcp

> tcp 提供可靠的网络数据传输

**为什么说 tcp 是可靠的**

1. **确认和重传机制**，建立链接时候的三次握手，传输过程中，如果丢包或者延时进行重传
2. **数据排序**，有专门的序列号 sn 字段
3. **流量控制**，窗口和计时器的使用，指明双方能够发送的最大数据量
4. **拥塞控制**
    - 慢启动 由小到大的逐渐增大发送窗口
    - 拥塞避免 一旦网络出现了拥塞，窗口就会减少一些，来缓解网络的拥塞。
    - 快速重传 每发送一个分段都会启动一个超时计时器，如果相应的分段在特定的时间内没有被送回 就会重发
    - 快速恢复 如果确认分段包丢失，进入拥塞控制阶段，如果仍然超时，则回到慢启动阶段。

#### webscoket

-   建立在 tcp 之上，与 http 有良好的兼容性，默认的端口也是 80 和 443，
-   数据格式轻量，性能开销比较小，通信高效
-   可以发送文本也可以发送二进制数据
-   没有同源限制，客户端可以与任意服务器通信
-   协议标识符是 ws ，如果加密就是 wss

#### cookie 和 session

**cookie：**是服务器在本地机器上存储的小段文本并随个请求发送至服务器。是用在客户端会话状态的存储机制。

**cookie 用途**：

-   会话状态管理 (用户登录，购物车，游戏分数)
-   个性化设置(换肤)
-   浏览器行为追踪

可以通过设置过期时间来清除 cookie

**Session**:是服务端的一种机制，服务端使用一种类似于散列表的结构来保存信息，通过 sessionid 来标识，而 cookie 通常是作为 sessionid 使用

**两者区别**

1. cookie 存在客户端的浏览器上，sessicon 存在服务器的一个文件中
2. cookie 的安全性比较差，但是性能开销比较小，sessioc 的安全性和隐私性比较高，但是性能开销大，访问多的时候，服务器的压力比较大
3. cookie 的存储数据不能超过 4k，并且只能保存 acsll 字符串。session 可以存储任何类型的数据
4. 有效期不一样
5. cookie 支持跨域名访问 session 不支持

**cookie,webStorage 区别**

1. 有效期不同，localstorage 永久有效
2. 作用域不同，localstorage 和 cookie 是所有同源窗口共享，session 不在不同的浏览器窗口共享 即使是同一个页面
3. 存储大小不同、

**cookie 的缺点：**

-   数量和长度限制 每个 domain 最多有 20 条 cookie 每个 cookie 的长度不超过 4kb
-   安全性问题 容易被拦截

**session 缺点：**

-   占用服务器资源 高并发的时候 服务端的压力较大
-   如果浏览器不兼容 cookie 那用户无法使用 session 这个遍历
-   session 的释放 有延迟性

#### 同域和跨域 ajax 请求 到底会不会携带 cookie

[Cookie 的设置、读取以及是否自动携带问题](https://juejin.im/post/5b5df0aee51d451998415485)

[[axios 携带 cookie 配置（axios+koa)](https://segmentfault.com/a/1190000017535086)

默认情况下，

-   不管是同域还是跨域请求 ajax 请求都不会带上 cookie，只有设置了 credentials 时才会携带 cookie，服务端需要设置 access-control-allow-Creadentials 为 true，否则浏览器会因为限制而报错

-   跨域请求需要设置 withCredentials 和服务端响应头

### CORS

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS

https://github.com/amandakelake/blog/issues/62

浏览器限制脚本跨域访问，对于非简单请求 会首先发起一个方法会 options 的预检请求，获知服务端是否允许跨域请求
服务端允许之后 才会发起实际的 http 请求

### 从输入 url 到页面加载发生了什么

-   浏览器缓存检查（）
-   DNS 域名解析（递归查询和分布式）
-   TCP 链接（三次挥手）
-   发送 http 请求
-   服务端 处理请求并返回 HTTP 报文（content-type判断出是什么内容）
-   htmlparser 解析 dom 生成 dom 树
-   cssparser 解析 css 生成 css tree
-   两者结合生成布局🌲，计算元素的布局信息
-   将布局树进行分层，得到分层树 发送给合成线程 
-   合成线程将图层转化为图块（256*256/512）,优先将视口附近的图块转化为位图，
-   合成线程发送drawQuad命令给浏览器
-   浏览器渲染页面

#### DNS 解析

-   DNS 解析是一个递归优化的过程，顺序为本地域名服务器—根域名服务器—顶级域名服务器—主域名服务器
-   DNS 的优化： DNS 缓存
-   DNS 负载均衡（DNS 重定向）在用户查询的时候 根据每台机器的负载数量 距离 用户的地理位置的距离 进行分配 (CDN 就是 DNS 的重定向技术)

#### TCP 链接

> tcp 是一个端到端的面向连接的协议。http 基于 tcp。客户端与服务端的 tcp 链接 也就是三次握手 而关闭链接的时候 需要四次挥手

-   三次握手

    -   第一次握手： 表明客户端打算链接服务器
    -   第二次： 服务端确定收到客服端应答 向客户端发送确认包应答
    -   第三次： 客服端再次发送确认包

-   四次挥手：

    -   第一次： 客户端想要关闭连接 表示自己没有数据可以发送了 但是依然可以接受数据

    -   第二次： 服务端确认收到 关闭连接的请求 但是还没有准备好关闭链接（还有数据没有传输完毕）

    -   第三次：服务端准备好关闭 向客户端发送结束链接请求

    -   第四次： 客服端接收端服务端的关闭请求 发送一个确认包进入 wait 状态 服务端收到确认包之后关闭链接进入 closed 状态。客户端等待个固定的时间（2msl）之后，没有收到服务端的 ack，于是自己也关闭连接，进入 closed 状态

        > 2msl 最大报文段生存时间 规定是 2 分钟 实际中常用的是 30 秒 1 分种和两分钟

**tcp 为什么需要三次握手**

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 换而言之： 防止 server 端一直等待，浪费资源。

```js
如果一个报文段已经失效了，连接释放以后的某个时间段到达服务端，没有第三次的确认，
server就会以为新的传输链接已经建立，并且会一直等待数据的传输，造成资源的浪费。
```

#### 什么是 SYN 攻击

> SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。

由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS 攻击。

**如何检测 SYN 攻击？**
检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

**如何防御 SYN 攻击？**
SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

-   缩短超时（SYN Timeout）
-   时间增加最大半连接数
-   过滤网关防护 SYN
-   cookies 技术

#### 浏览器解析 html

参考文献： https://blog.poetries.top/browser-working-principle/

1. 浏览器是一个边解析 边渲染的过程
2. 首先浏览器
    - htmlparser 解析 html 文件构建 DOM 树，
    - cssParser 解析 css 文件构建渲染树，
    - 二者关联生成 render Tree ，layout 根据 Render Tree 计算节点的信息 ，布局 renderTree，然后绘制页面

**详细解读**

-   html parser 的任务是将 html 解析为 DOM Tree

-   浏览器就是依靠 Content-Type 来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠 URL 来判断响应的内容，所以，即使 URL 是`http://www.baidu.com/meimei.jpg`，它也不一定就是图片。

    ```js
    Content-Type: text/html
    ```

-   css 计算复合图层 绘制命令交给合成线程
-   合成线程优先将视口附近的图库 转化为位图 发送 drawqurad 命令给浏览器
-   浏览器将内容绘制到内存中 进而显示到页面中

-   阻塞渲染

    -   js 阻塞 dom 解析 但是浏览器会检测后续的 html 进行预下载

    -   script 标签中 acyns 和 defer 的区别

        -   async 脚本在下载完毕之后异步执行
        -   defer 脚本在页面解析完毕之后 立即执行

        ![image.png](https://upload-images.jianshu.io/upload_images/5703029-6e5f14577bbe7ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    -   css 不会阻塞 DOM 的解析 但是会阻塞 DOM 的渲染（减少回流和重绘。来节省性能）

##### 注意 考察点

1. 浏览器缓存 dns
    - 浏览器缓存--操作系统缓存—路由器缓存—网络供应商缓存
    - chrome 的缓存是 1 分钟左右 sarifi 的大约为 30 秒
2. https 多了一个什么步骤

> https 是 http 协议的加密版本，通常使用 tls 或者 ssl 来加密客服端和服务端之前所有的通信

-   需要 ca 申请 ssl 证书
-   端口号不一样 http 是 80 https 是 443
-   https 相比于 http 多了一层 ssl 协议 ssl 协议握手需要 9 个包 ，https 对网站的响应速度有负面影响。

1. 假如客户端最大下行 10m，服务端最大上行 100m，服务端会以 10m 的速率发包吗
2. 如果加载一个 link 标签 需要 10 秒 加载时用户会看到什么
3. 如果外联一个 script 标签需要 10 秒，用户会看到什么

##### 关键渲染路径

1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。
