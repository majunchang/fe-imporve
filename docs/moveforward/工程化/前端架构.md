###  前端架构 



##### 前端架构设计
层次设计原则
https://segmentfault.com/a/1190000038830039

1. 应用层面
   - 打包和编译
   - 上线流程
   - 目录的设计层级
     - views
     - model
     - api
     - utils
     - components
   - 组件的复用
2. 开发层面
   - 技术选型
   - 代码的开发规范性（代码设计之美，unix哲学，）
     - 函数单一原则
     - es6 展开对象 默认参数
     - 可选链式调用
     - 组件的封装原则
   - 提交的规范性
   - eslint
   - git commit lint
   - 单元测试

##### 微前端实践方案 

MPA的方案：部署简单，各个应用之间隔离，各个应用之间部署相对独立，应用之间的跳转会造成浏览器页面的刷新，流程体验存在断点

SPA方案：应用可以无刷新切换，应用之间的技术栈联系紧密

最初的系统在经历过漫长的迭代之后，最终可能发展为一个巨石应用，想要对整个项目做技术更新 基本上是不可能的，且会造成很大的风险性。于是微前端应运而生

##### 微前端实践中的问题

- **路由系统 **

- **构建时组合VS运行时组合（上线方式）**

- **JS Entry VS Html Entry**

- 模块导入

- 应用隔离

  



路由系统：

1. 主框架加载子路由的时候，子路由如果没有加载完毕，会导致当前页面redirect或者报错
2. **解决方案**：当子系统加载进主应用的路由系统之后，子系统再去监听url的change事件，同时当子系统切出之后，触发主系统的destory事件，子组件对应的卸载应用
3. 社区中有比较完善的实践：single-spa

**构建时组合VS运行时组合**

- 构建时组合 ： 子应用通过git tag(npm package)的方式 随着主应用一起打包发布
- 运行时组合： 子应用单独构建打包上线，主应用动态加载子应用资源



**JS Entry VS Html Entry**（子应用的渲染入口）

- JS： （备注： 参考nodeJs打包） 所有的资源比如 css，图片都会被整合到一个js文件里面，除了包的体积过大之后，资源的并行加载也无法实现。
- html：子应用提供一个html入口，主应用通过fetch html的方式 加载子应用，



模块导入

某些情况下，需要获取到子应用暴露出来的一些钩子引用，

- 子应用与主框架约定一个全局变量
- umd格式下  global export的方式 获取  



应用隔离

- 样式隔离
  - css in js,css module
  - shadow dom（封闭的 不允许外部访问 类似于bfc）
  - 动态样式表（子应用切入的时候 动态加载 子应用卸载的时候 动态移除）
- js隔离
  - 类似于git checkout   加载之前保存一份变量的快照  卸载之后恢复加载之前的快照



https://zhuanlan.zhihu.com/p/78362028
https://github.com/single-spa/single-spa
https://github.com/umijs/qiankun



前端发布生产包 清理浏览器缓存的方案

